const __locales = ["fi"]

const __formatNumber = (value, options) => {
	return new Intl.NumberFormat(__locales, options).format(value)
}

const __formatVariable = (value) => {
  if (typeof value === 'string') return value
  const decimal =  Number.parseFloat(value)
  const number = Number.isInteger(decimal) ? Number.parseInt(value) : decimal
  return __formatNumber(number)
}

const __select = (value, cases, fallback, options) => {
	const pluralRules = new Intl.PluralRules(__locales, options)
	const rule = pluralRules.select(value)
	return cases[value] ?? cases[rule] ?? fallback
}

const defaultMessage = (params) => `täytyy läpäistä "${params?.keyword}" avainsanatarkistus`
const comparisonLimit = (params) => `täytyy olla ${params?.comparison} ${params?.limit}`
export const items = (params) => `saa sisältää enintään ${__formatVariable(params?.limit)}${__select(
    params?.limit,
    {
      'one': `:n elementin`
    },
    `elementtiä`
  )}`
export const additionalItems = (params) => `${items(params)}`
export const additionalProperties = `ei saa sisältää ylimääräisiä ominaisuuksia`
export const anyOf = `täytyy vastata "anyOf" skeemaa`
export const _const = `täytyy olla yhtä kuin vakio`
export const contains = `täytyy sisältää kelvollinen elementti`
export const dependencies = (params) => `täytyy sisältää ${__formatVariable(params?.deps)} ${__select(
    params?.depsCount,
    {
      'one': `ominaisuus`
    },
    `ominaisuudet`
  )} kun ${__formatVariable(params?.property)}-ominaisuus on läsnä`
export const dependentRequired = (params) => `${dependencies(params)}`
export const _enum = `täytyy olla yhtä kuin jokin sallituista arvoista`
export const falseSchema = `boolean skeema on väärä`
export const format = (params) => `täytyy vastata muotoa "${__formatVariable(params?.format)}"`
export const formatMaximum = (params) => `${comparisonLimit(params)}`
export const formatExclusiveMaximum = (params) => `${comparisonLimit(params)}`
export const formatMinimum = (params) => `${comparisonLimit(params)}`
export const formatExclusiveMinimum = (params) => `${comparisonLimit(params)}`
export const _if = (params) => `täytyy vastata "${__formatVariable(params?.failingKeyword)}" skeemaa`
export const maximum = (params) => `${comparisonLimit(params)}`
export const exclusiveMaximum = (params) => `${maximum(params)}`
export const maxItems = (params) => `tulee sisältää enintään ${__formatVariable(params?.limit)} ${__select(
    params?.limit,
    {
      'one': `elementti`
    },
    `elementtiä`
  )}`
export const maxLength = (params) => `ei saa olla pidempi kuin ${__formatVariable(params?.limit)} ${__select(
    params?.limit,
    {
      'one': `merkki`
    },
    `merkkiä`
  )}`
export const maxProperties = (params) => `tulee sisältää enintään ${__formatVariable(params?.limit)} ${__select(
    params?.limit,
    {
      'one': `ominaisuus`
    },
    `ominaisuutta`
  )}`
export const minimum = (params) => `${comparisonLimit(params)}`
export const exclusiveMinimum = (params) => `${minimum(params)}`
export const minItems = (params) => `tulee sisältää vähintään ${__formatVariable(params?.limit)} ${__select(
    params?.limit,
    {
      'one': `elementti`
    },
    `elementtiä`
  )}`
export const minLength = (params) => `ei saa olla lyhyempi kuin ${__formatVariable(params?.limit)} ${__select(
    params?.limit,
    {
      'one': `merkki`
    },
    `merkkiä`
  )}`
export const minProperties = (params) => `tulee sisältää vähintään ${__formatVariable(params?.limit)} ${__select(
    params?.limit,
    {
      'one': `ominaisuus`
    },
    `ominaisuutta`
  )}`
export const multipleOf = (params) => `täytyy olla moninkertainen: ${__formatVariable(params?.multipleOf)}`
export const not = `ei saa olla hyväksytty skeeman "not" mukaan`
export const oneOf = `täytyy vastata täsmälleen yhtä "oneOf" -kohdassa määriteltyä skeemaa`
export const pattern = (params) => `täytyy vastata muotoa "${__formatVariable(params?.pattern)}"`
export const patternRequired = (params) => `täytyy sisältää ominaisuus joka vastaa kaavaa "${__formatVariable(params?.missingPattern)}"`
export const propertyNames = `ominaisuuden nimi on virheellinen`
export const required = (params) => `täytyy sisältää vaadittu ominaisuus ${__formatVariable(params?.missingProperty)}`
export const type = (params) => `täytyy olla ${__select(
    params?.type,
    {
      'number': `numero`,
      'integer': `kokonaisluku`,
      'string': `merkkijono`,
      'boolean': `boolean`
    },
    `${__formatVariable(params?.type)}`
  )}${__select(
    params?.nullable,
    {
      'true': `/null`
    },
    `${""}`
  )}`
export const unevaluatedItems = (params) => `ei saa olla enemmän kuin ${__formatVariable(params?.len)} ${__select(
    params?.len,
    {
      'one': `elementti`
    },
    `elementtiä`
  )}`
export const unevaluatedProperties = `ei saa sisältää arvioimattomia ominaisuuksia`
export const uniqueItems = (params) => `ei saa sisältää duplikaatteja (elementit ## ${__formatVariable(params?.j)} ja ${__formatVariable(params?.i)} ovat identtiset)`
export const discriminator = (params) => `${__select(
    params?.error,
    {
      'tag': `tunniste "${__formatVariable(params?.tag)}" täytyy olla merkkijono`,
      'mapping': `tunnisteen arvon "${__formatVariable(params?.tag)}" on oltava kartoituksessa`
    },
    `${type(params)}`
  )}`
export const properties = (params) => `${__select(
    params?.error,
    {
      'additional': `ei saa sisältää ylimääräisiä ominaisuuksia`,
      'missing': `täytyy sisältää ominaisuus ${__formatVariable(params?.missingProperty)}`
    },
    `${type(params)}`
  )}`
export const elements = (params) => `${type(params)}`
export const values = (params) => `${type(params)}`
export const union = `täytyy vastata "union" skeemaa`
const __exports = {
  items,
  additionalItems,
  additionalProperties,
  anyOf,
  'const': _const,
  contains,
  dependencies,
  dependentRequired,
  'enum': _enum,
  falseSchema,
  format,
  formatMaximum,
  formatExclusiveMaximum,
  formatMinimum,
  formatExclusiveMinimum,
  'if': _if,
  maximum,
  exclusiveMaximum,
  maxItems,
  maxLength,
  maxProperties,
  minimum,
  exclusiveMinimum,
  minItems,
  minLength,
  minProperties,
  multipleOf,
  not,
  oneOf,
  pattern,
  patternRequired,
  propertyNames,
  required,
  type,
  unevaluatedItems,
  unevaluatedProperties,
  uniqueItems,
  discriminator,
  properties,
  elements,
  values,
  union
}
export default (errors) => {
  if (!errors?.length) return
  for (const e of errors) {
    let { keyword } = e
    if (keyword === 'false schema') keyword = 'falseSchema'
    let source = __exports[keyword] ?? __exports['_'+keyword]
    let values = {}
    if (keyword === 'errorMessage') {
      const [message, ...valuesPairs] = e.message.split(', ')
      ;(valuesPairs.join(', ').match(regExpJsonPointerPairs) ?? []).forEach(pair => {
        const [key, value] = pair.split(':')
        values[key] = value.replace(regExpJsonPointerQuote, '')
      })
      source ??= __exports[message] ?? __exports['_'+message] ?? e.message
    } else {
      source ??= __exports.defaultMessage
    }
    if (typeof source === 'function') {
      e.message = source({keyword:e.keyword, ...e.params, ...values})
    } else {
      e.message = source
    }
  }
}
const regExpJsonPointerPairs = /([a-zA-Z0-9_-]+):(".*"|[^,"]+)/g
const regExpJsonPointerQuote = /(^"|"$)/g
